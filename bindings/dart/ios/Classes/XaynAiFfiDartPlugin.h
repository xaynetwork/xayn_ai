#import <Flutter/Flutter.h>

@interface XaynAiFfiDartPlugin : NSObject<FlutterPlugin>
@end
/* Generated with cbindgen:0.18.0 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdint.h>

/**
 * The Xayn AI error codes.
 */
enum CCode {
  /**
   * An uncritical error.
   */
  Warning = -2,
  /**
   * An irrecoverable error.
   */
  Panic = -1,
  /**
   * No error.
   */
  Success = 0,
  /**
   * A vocab null pointer error.
   */
  VocabPointer = 1,
  /**
   * A model null pointer error.
   */
  ModelPointer = 2,
  /**
   * A vocab or model file IO error.
   */
  ReadFile = 3,
  /**
   * A Xayn AI initialization error.
   */
  InitAi = 4,
  /**
   * A Xayn AI null pointer error.
   */
  AiPointer = 5,
  /**
   * A document histories null pointer error.
   */
  HistoriesPointer = 6,
  /**
   * A document history id null pointer error.
   */
  HistoryIdPointer = 7,
  /**
   * A documents null pointer error.
   */
  DocumentsPointer = 8,
  /**
   * A document id null pointer error.
   */
  DocumentIdPointer = 9,
  /**
   * A document snippet null pointer error.
   */
  DocumentSnippetPointer = 10,
  /**
   * Deserialization of reranker database error.
   */
  RerankerDeserialization = 11,
  /**
   * Serialization of reranker database error.
   */
  RerankerSerialization = 12,
};
typedef int32_t CCode;

/**
 * A user feedback level.
 */
enum CFeedback {
  Relevant = 0,
  Irrelevant = 1,
  None = 2,
};
typedef uint8_t CFeedback;

/**
 * A document relevance level.
 */
enum CRelevance {
  Low = 0,
  Medium = 1,
  High = 2,
};
typedef uint8_t CRelevance;

/**
 * The raw analytics.
 */
typedef struct CAnalytics CAnalytics;

/**
 * The Xayn AI.
 *
 * # Examples
 * - Create a Xayn AI with [`xaynai_new()`].
 * - Rerank documents with [`xaynai_rerank()`].
 * - Free memory with [`xaynai_drop()`], [`ranks_drop()`] and [`error_message_drop()`].
 *
 * [`ranks_drop()`]: crate::data::rank::ranks_drop
 * [`error_message_drop()`]: crate::result::error::error_message_drop
 */
typedef struct CXaynAi CXaynAi;

/**
 * A raw slice of ranks.
 *
 * The ranks are in the same logical order as the documents used in [`xaynai_rerank()`].
 *
 * [`xaynai_rerank()`]: crate::reranker::ai::xaynai_rerank
 */
typedef struct CRanks {
  /**
   * The raw pointer to the ranks.
   */
  const uint32_t *data;
  /**
   * The number of ranks.
   */
  uint32_t len;
} CRanks;

/**
 * `FfiStr<'a>` is a safe (`#[repr(transparent)]`) wrapper around a
 * nul-terminated `*const c_char` (e.g. a C string). Conceptually, it is
 * similar to [`std::ffi::CStr`], except that it may be used in the signatures
 * of extern "C" functions.
 *
 * Functions accepting strings should use this instead of accepting a C string
 * directly. This allows us to write those functions using safe code without
 * allowing safe Rust to cause memory unsafety.
 *
 * A single function for constructing these from Rust ([`FfiStr::from_raw`])
 * has been provided. Most of the time, this should not be necessary, and users
 * should accept `FfiStr` in the parameter list directly.
 *
 * ## Caveats
 *
 * An effort has been made to make this struct hard to misuse, however it is
 * still possible, if the `'static` lifetime is manually specified in the
 * struct. E.g.
 *
 * ```rust,no_run
 * # use ffi_support::FfiStr;
 * // NEVER DO THIS
 * #[no_mangle]
 * extern "C" fn never_do_this(s: FfiStr<'static>) {
 *     // save `s` somewhere, and access it after this
 *     // function returns.
 * }
 * ```
 *
 * Instead, one of the following patterns should be used:
 *
 * ```
 * # use ffi_support::FfiStr;
 * #[no_mangle]
 * extern "C" fn valid_use_1(s: FfiStr<'_>) {
 *     // Use of `s` after this function returns is impossible
 * }
 * // Alternative:
 * #[no_mangle]
 * extern "C" fn valid_use_2(s: FfiStr) {
 *     // Use of `s` after this function returns is impossible
 * }
 * ```
 */
typedef const char *CStr;

/**
 * A raw slice of bytes.
 */
typedef struct CBytes {
  /**
   * The raw pointer to the bytes.
   */
  const uint8_t *data;
  /**
   * The number of bytes.
   */
  uint32_t len;
} CBytes;

/**
 * Represents an error that occured within rust, storing both an error code, and additional data
 * that may be used by the caller.
 *
 * Misuse of this type can cause numerous issues, so please read the entire documentation before
 * usage.
 *
 * ## Rationale
 *
 * This library encourages a pattern of taking a `&mut ExternError` as the final parameter for
 * functions exposed over the FFI. This is an "out parameter" which we use to write error/success
 * information that occurred during the function's execution.
 *
 * To be clear, this means instances of `ExternError` will be created on the other side of the FFI,
 * and passed (by mutable reference) into Rust.
 *
 * While this pattern is not particularly ergonomic in Rust (although hopefully this library
 * helps!), it offers two main benefits over something more ergonomic (which might be `Result`
 * shaped).
 *
 * 1. It avoids defining a large number of `Result`-shaped types in the FFI consumer, as would
 *    be required with something like an `struct ExternResult<T> { ok: *mut T, err:... }`
 *
 * 2. It offers additional type safety over `struct ExternResult { ok: *mut c_void, err:... }`,
 *    which helps avoid memory safety errors. It also can offer better performance for returning
 *    primitives and repr(C) structs (no boxing required).
 *
 * It also is less tricky to use properly than giving consumers a `get_last_error()` function, or
 * similar.
 *
 * ## Caveats
 *
 * Note that the order of the fields is `code` (an i32) then `message` (a `*mut c_char`), getting
 * this wrong on the other side of the FFI will cause memory corruption and crashes.
 *
 * The fields are public largely for documentation purposes, but you should use
 * [`ExternError::new_error`] or [`ExternError::success`] to create these.
 *
 * ## Layout/fields
 *
 * This struct's field are not `pub` (mostly so that we can soundly implement `Send`, but also so
 * that we can verify rust users are constructing them appropriately), the fields, their types, and
 * their order are *very much* a part of the public API of this type. Consumers on the other side
 * of the FFI will need to know its layout.
 *
 * If this were a C struct, it would look like
 *
 * ```c,no_run
 * struct ExternError {
 *     int32_t code;
 *     char *message; // note: nullable
 * };
 * ```
 *
 * In rust, there are two fields, in this order: `code: ErrorCode`, and `message: *mut c_char`.
 * Note that ErrorCode is a `#[repr(transparent)]` wrapper around an `i32`, so the first property
 * is equivalent to an `i32`.
 *
 * #### The `code` field.
 *
 * This is the error code, 0 represents success, all other values represent failure. If the `code`
 * field is nonzero, there should always be a message, and if it's zero, the message will always be
 * null.
 *
 * #### The `message` field.
 *
 * This isÂ a null-terminated C string containing some amount of additional information about the
 * error. If the `code` property is nonzero, there should always be an error message. Otherwise,
 * this should will be null.
 *
 * This string (when not null) is allocated on the rust heap (using this crate's
 * [`rust_string_to_c`]), and must be freed on it as well. Critically, if there are multiple rust
 * packages using being used in the same application, it *must be freed on the same heap that
 * allocated it*, or you will corrupt both heaps.
 *
 * Typically, this object is managed on the other side of the FFI (on the "FFI consumer"), which
 * means you must expose a function to release the resources of `message` which can be done easily
 * using the [`define_string_destructor!`] macro provided by this crate.
 *
 * If, for some reason, you need to release the resources directly, you may call
 * `ExternError::release()`. Note that you probably do not need to do this, and it's
 * intentional that this is not called automatically by implementing `drop`.
 *
 * ## Example
 *
 * ```rust,no_run
 * use ffi_support::{ExternError, ErrorCode};
 *
 * #[derive(Debug)]
 * pub enum MyError {
 *     IllegalFoo(String),
 *     InvalidBar(i64),
 *     // ...
 * }
 *
 * // Putting these in a module is obviously optional, but it allows documentation, and helps
 * // avoid accidental reuse.
 * pub mod error_codes {
 *     // note: -1 and 0 are reserved by ffi_support
 *     pub const ILLEGAL_FOO: i32 = 1;
 *     pub const INVALID_BAR: i32 = 2;
 *     // ...
 * }
 *
 * fn get_code(e: &MyError) -> ErrorCode {
 *     match e {
 *         MyError::IllegalFoo(_) => ErrorCode::new(error_codes::ILLEGAL_FOO),
 *         MyError::InvalidBar(_) => ErrorCode::new(error_codes::INVALID_BAR),
 *         // ...
 *     }
 * }
 *
 * impl From<MyError> for ExternError {
 *     fn from(e: MyError) -> ExternError {
 *         ExternError::new_error(get_code(&e), format!("{:?}", e))
 *     }
 * }
 * ```
 */
typedef struct CError {
  CCode code;
  char *message;
} CError;

/**
 * A raw document history.
 */
typedef struct CHistory {
  /**
   * The raw pointer to the document id.
   */
  CStr id;
  /**
   * The relevance level of the document.
   */
  CRelevance relevance;
  /**
   * The user feedback level of the document.
   */
  CFeedback feedback;
} CHistory;

/**
 * A raw slice of document histories.
 */
typedef struct CHistories {
  /**
   * The raw pointer to the document histories.
   */
  const struct CHistory *data;
  /**
   * The number of document histories.
   */
  uint32_t len;
} CHistories;

/**
 * A raw document.
 */
typedef struct CDocument {
  /**
   * The raw pointer to the document id.
   */
  CStr id;
  /**
   * The raw pointer to the document snippet.
   */
  CStr snippet;
  /**
   * The rank of the document.
   */
  uint32_t rank;
} CDocument;

/**
 * A raw slice of documents.
 */
typedef struct CDocuments {
  /**
   * The raw pointer to the documents.
   */
  const struct CDocument *data;
  /**
   * The number of documents.
   */
  uint32_t len;
} CDocuments;

/**
 * A raw slice of warnings.
 */
typedef struct CWarnings {
  /**
   * The raw pointer to the warnings.
   */
  const struct CError *data;
  /**
   * The number of warnings.
   */
  uint32_t len;
} CWarnings;

/**
 * Frees the memory of the ranks.
 *
 * # Safety
 * The behavior is undefined if:
 * - A non-null `ranks` doesn't point to memory allocated by [`xaynai_rerank()`].
 * - A non-null `ranks` is freed more than once.
 * - A non-null `ranks` is accessed after being freed.
 *
 * [`xaynai_rerank()`]: crate::reranker::ai::xaynai_rerank
 */
void ranks_drop(struct CRanks *ranks);

/**
 * Creates and initializes the Xayn AI.
 *
 * Requires the vocabulary and model of the tokenizer/embedder. Optionally accepts the serialized
 * reranker database, otherwise creates a new one.
 *
 * # Errors
 * Returns a null pointer if:
 * - The `vocab` or `model` paths are invalid.
 * - The `serialized` database is invalid.
 * - An unexpected panic happened.
 *
 * # Safety
 * The behavior is undefined if:
 * - A non-null `serialized` database doesn't point to an aligned, contiguous area of memory.
 * - A serialized database `size` is too large to address the memory of a non-null serialized
 * database array.
 * - A non-null `vocab` or `model` path doesn't point to an aligned, contiguous area of memory with
 * a terminating null byte.
 * - A non-null `error` doesn't point to an aligned, contiguous area of memory with an
 * [`ExternError`].
 */
struct CXaynAi *xaynai_new(CStr vocab,
                           CStr model,
                           const struct CBytes *serialized,
                           struct CError *error);

/**
 * Reranks the documents with the Xayn AI.
 *
 * # Errors
 * Returns a null pointer if:
 * - The `xaynai` is null.
 * - The document `histories` are invalid.
 * - The `documents` are invalid.
 * - An unexpected panic happened.
 *
 * In case of a [`CCode::Panic`], the `xaynai` is dropped and must not be accessed anymore. The
 * last known valid state can be restored by the caller via [`xaynai_new()`] with a previously
 * serialized reranker database obtained from [`xaynai_serialize()`].
 *
 * # Safety
 * The behavior is undefined if:
 * - A non-null `xaynai` doesn't point to memory allocated by [`xaynai_new()`].
 * - A non-null `histories` doesn't point to an aligned, contiguous are of memory with a
 * [`CHistories`].
 * - A non-null histories `data` doesn't point to an aligned, contiguous area of memory with
 * at least histories `len` many [`CHistory`]s.
 * - A histories `len` is too large to address the memory of a non-null [`CHistory`] array.
 * - A non-null `documents` doesn't point to an aligned, contiguous area of memory with a
 * [`CDocuments`].
 * - A non-null documents `data` doesn't point to an aligned, contiguous area of memory with
 * at least documents `len` many [`CDocument`]s.
 * - A documents `len` is too large to address the memory of a non-null [`CDocument`] array.
 * - A non-null `id` or `snippet` doesn't point to an aligned, contiguous area of memory with a
 * terminating null byte.
 * - A non-null `error` doesn't point to an aligned, contiguous area of memory with an
 * [`ExternError`].
 * - A non-null `xaynai` is accessed after a panic.
 *
 * [`CHistory`]: crate::data::history::CHistory
 * [`CDocument`]: crate::data::document::CDocument
 */
struct CRanks *xaynai_rerank(struct CXaynAi *xaynai,
                             const struct CHistories *histories,
                             const struct CDocuments *documents,
                             struct CError *error);

/**
 * Serializes the database of the reranker.
 *
 * # Errors
 * Returns a null pointer if:
 * - The xaynai is null.
 * - The serialization fails.
 * - An unexpected panic happened.
 *
 * # Safety
 * The behavior is undefined if:
 * - A non-null xaynai doesn't point to memory allocated by [`xaynai_new()`].
 * - A non-null error doesn't point to an aligned, contiguous area of memory with an
 * [`ExternError`].
 */
struct CBytes *xaynai_serialize(struct CXaynAi *xaynai, struct CError *error);

/**
 * Retrieves warnings which might occur during reranking.
 *
 * # Errors
 * Returns a null pointer if:
 * - The `xaynai` is null.
 * - An unexpected panic happened.
 *
 * # Safety
 * The behavior is undefined if:
 * - A non-null `xaynai` doesn't point to memory allocated by [`xaynai_new()`].
 * - A non-null `error` doesn't point to an aligned, contiguous area of memory with an
 * [`ExternError`].
 */
struct CWarnings *xaynai_warnings(struct CXaynAi *xaynai, struct CError *error);

/**
 * Retrieves the analytics which were collected in the penultimate reranking.
 *
 * # Errors
 * Returns a null pointer if:
 * - The `xaynai` is null.
 * - An unexpected panic happened.
 *
 * # Safety
 * The behavior is undefined if:
 * - A non-null `xaynai` doesn't point to memory allocated by [`xaynai_new()`].
 * - A non-null `error` doesn't point to an aligned, contiguous area of memory with an
 * [`ExternError`].
 */
struct CAnalytics *xaynai_analytics(struct CXaynAi *xaynai, struct CError *error);

/**
 * Frees the memory of the Xayn AI.
 *
 * # Safety
 * The behavior is undefined if:
 * - A non-null `xaynai` doesn't point to memory allocated by [`xaynai_new()`].
 * - A non-null `xaynai` is freed more than once.
 * - A non-null `xaynai` is accessed after being freed.
 */
void xaynai_drop(struct CXaynAi *xaynai);

/**
 * Frees the memory of the analytics.
 *
 * # Safety
 * The behavior is undefined if:
 * - A non-null `analytics` doesn't point to memory allocated by [`xaynai_analytics()`].
 * - A non-null `analytics` is freed more than once.
 * - A non-null `analytics` is accessed after being freed.
 *
 * [`xaynai_analytics()`]: crate::reranker::ai::xaynai_analytics
 */
void analytics_drop(struct CAnalytics *analytics);

/**
 * Frees the memory of the bytes buffer.
 *
 * # Safety
 * The behavior is undefined if:
 * - A non-null `bytes` buffer doesn't point to memory allocated by [`xaynai_serialize()`].
 * - A non-null `bytes` buffer is freed more than once.
 * - A non-null `bytes` buffer is accessed after being freed.
 *
 * [`xaynai_serialize()`]: crate::reranker::ai::xaynai_serialize
 */
void bytes_drop(struct CBytes *buffer);

/**
 * Frees the memory of the error message.
 *
 * This *does not* free the error memory itself, which is allocated somewhere else. But this *does*
 * free the message field memory of the error. Not freeing the error message on consecutive errors
 * (ie. where the error code is not success) will potentially leak the error message memory of the
 * overwritten error.
 *
 * # Safety
 * The behavior is undefined if:
 * - A non-null `error` doesn't point to an aligned, contiguous area of memory with an
 * [`ExternError`].
 * - A non-null error `message` doesn't point to memory allocated by [`xaynai_new()`],
 * [`xaynai_rerank()`], [`xaynai_serialize()`], [`xaynai_warnings()`] or [`xaynai_analytics()`].
 * - A non-null error `message` is freed more than once.
 * - A non-null error `message` is accessed after being freed.
 *
 * [`xaynai_new()`]: crate::reranker::ai::xaynai_new
 * [`xaynai_rerank()`]: crate::reranker::ai::xaynai_rerank
 * [`xaynai_serialize()`]: crate::reranker::ai::xaynai_serialize
 * [`xaynai_warnings()`]: crate::reranker::ai::xaynai_warnings
 * [`xaynai_analytics()`]: crate::reranker::ai::xaynai_analytics
 */
void error_message_drop(struct CError *error);

/**
 * Frees the memory of the warnings.
 *
 * # Safety
 * The behavior is undefined if:
 * - A non-null `warnings` doesn't point to memory allocated by [`xaynai_warnings()`].
 * - A non-null `warnings` is freed more than once.
 * - A non-null `warnings` is accessed after being freed.
 *
 * [`xaynai_warnings()`]: crate::reranker::ai::xaynai_warnings
 */
void warnings_drop(struct CWarnings *warnings);

/**
 * This function does nothing.
 *
 * Calling this prevents Swift to drop the library.
 */
void dummy_function(void);
