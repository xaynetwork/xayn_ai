// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings to the xayn-ai-ffi-c library.
class XaynAiFfi {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  XaynAiFfi(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  XaynAiFfi.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Runs the destructor on a `Option<Box<CRerankingOutcomes>>`.
  ///
  /// You can pass in a potential null pointer, but if the pointer
  /// is not null it must be valid for usage in rust.
  ///
  /// This **moves ownership** from C-FFI to rust, the pointer
  /// (or any pointer derived from it/it was derived from)
  /// MUST NOT be used after this function was called.
  ///
  /// Doing so would implicitly violate rust's safety guarantees.
  ///
  /// # Safety
  ///
  /// This is safe (in rust terms) as long as the C-FFI does keep its
  /// constraints and doesn't violate any rust constraints wrt. the
  /// passed in data (which makes it always rust-safe).
  ///
  /// Explicitly:
  ///
  /// - Either the pointer must be null or
  /// - it must have been allocated by rusts global allocator
  /// - it must be aligned properly and non-dangling
  /// - which always should be the case if it was properly allocated by rust
  /// - and the data-structure behind the pointer must not have been changed in
  /// any way which would break rust invariants (just don't change it at all!).
  void reranking_outcomes_drop(
    ffi.Pointer<CRerankingOutcomes> _reranking_outcomes,
  ) {
    return _reranking_outcomes_drop(
      _reranking_outcomes,
    );
  }

  late final _reranking_outcomes_dropPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<CRerankingOutcomes>)>>('reranking_outcomes_drop');
  late final _reranking_outcomes_drop = _reranking_outcomes_dropPtr
      .asFunction<void Function(ffi.Pointer<CRerankingOutcomes>)>();

  /// Initializes the global thread pool. The thread pool is used by the AI to
  /// parallelize some of its tasks.
  ///
  /// The number of threads spawned by the pool corresponds to the value of `num_cpus`.
  /// If the value of `num_cpus` is `0`, the number of spawned threads corresponds to
  /// the number of logical CPUs.
  ///
  /// # Errors
  /// - If the initialization of the thread pool has failed.
  /// - An unexpected panic happened during the initialization of the thread pool.
  ///
  /// # Safety
  ///
  /// It is safe to call this function multiple times but it must be invoked
  /// before calling any of the `xaynai_*` functions.
  ///
  /// The behavior is undefined if:
  /// - A non-null `error` doesn't point to an aligned, contiguous area of memory with a [`CError`].
  void xaynai_init_thread_pool(
    int num_cpus,
    ffi.Pointer<CError> error,
  ) {
    return _xaynai_init_thread_pool(
      num_cpus,
      error,
    );
  }

  late final _xaynai_init_thread_poolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Uint64, ffi.Pointer<CError>)>>('xaynai_init_thread_pool');
  late final _xaynai_init_thread_pool = _xaynai_init_thread_poolPtr
      .asFunction<void Function(int, ffi.Pointer<CError>)>();

  /// Creates and initializes the Xayn AI.
  ///
  /// Requires the vocabulary and model of the tokenizer/embedder. Optionally accepts the serialized
  /// reranker database, otherwise creates a new one.
  ///
  /// # Errors
  /// Returns a null pointer if:
  /// - The `vocab` or `model` paths are invalid.
  /// - The `serialized` database is invalid.
  /// - An unexpected panic happened.
  ///
  /// # Safety
  /// The behavior is undefined if:
  /// - A non-null `vocab` or `model` path doesn't point to an aligned, contiguous area of memory with
  /// a terminating null byte.
  /// - A non-null `serialized` database doesn't point to an aligned, contiguous area of memory.
  /// - A serialized database `len` is too large to address the memory of a non-null serialized
  /// database array.
  /// - A non-null `error` doesn't point to an aligned, contiguous area of memory with a [`CError`].
  ffi.Pointer<CXaynAi> xaynai_new(
    ffi.Pointer<ffi.Uint8> smbert_vocab,
    ffi.Pointer<ffi.Uint8> smbert_model,
    ffi.Pointer<ffi.Uint8> qambert_vocab,
    ffi.Pointer<ffi.Uint8> qambert_model,
    ffi.Pointer<ffi.Uint8> ltr_model,
    ffi.Pointer<CBytes> serialized,
    ffi.Pointer<CError> error,
  ) {
    return _xaynai_new(
      smbert_vocab,
      smbert_model,
      qambert_vocab,
      qambert_model,
      ltr_model,
      serialized,
      error,
    );
  }

  late final _xaynai_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<CXaynAi> Function(
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<CBytes>,
              ffi.Pointer<CError>)>>('xaynai_new');
  late final _xaynai_new = _xaynai_newPtr.asFunction<
      ffi.Pointer<CXaynAi> Function(
          ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<CBytes>,
          ffi.Pointer<CError>)>();

  /// Reranks the documents with the Xayn AI.
  ///
  /// # Errors
  /// Returns a null pointer if:
  /// - The `xaynai` is null.
  /// - The document `histories` are invalid.
  /// - The `documents` are invalid.
  /// - An unexpected panic happened.
  ///
  /// In case of a [`CCode::Panic`] the Xayn AI must not be accessed anymore and should be dropped via
  /// [`xaynai_drop()`]. The last known valid state can be restored by the caller via [`xaynai_new()`]
  /// with a previously serialized reranker database obtained from [`xaynai_serialize()`].
  ///
  /// # Safety
  /// The behavior is undefined if:
  /// - A non-null `xaynai` doesn't point to memory allocated by [`xaynai_new()`].
  /// - A non-null `histories` doesn't point to an aligned, contiguous are of memory with a
  /// [`CHistories`] instance and all safety invariants of [`CHistories`] are uphold.
  /// - A non-null `documents` doesn't point to an aligned, contiguous are of memory with a
  /// [`CDocuments`] instance and all safety invariants of [`CDocuments`] are uphold.
  /// - A non-null `error` doesn't point to an aligned, contiguous area of memory with a [`CError`].
  /// - A non-null `xaynai` is accessed after a panic.
  ///
  /// [`CHistory`]: crate::data::history::CHistory
  /// [`CDocument`]: crate::data::document::CDocument
  ffi.Pointer<CRerankingOutcomes> xaynai_rerank(
    ffi.Pointer<CXaynAi> xaynai,
    int mode,
    ffi.Pointer<CHistories> histories,
    ffi.Pointer<CDocuments> documents,
    ffi.Pointer<CError> error,
  ) {
    return _xaynai_rerank(
      xaynai,
      mode,
      histories,
      documents,
      error,
    );
  }

  late final _xaynai_rerankPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<CRerankingOutcomes> Function(
              ffi.Pointer<CXaynAi>,
              RerankMode,
              ffi.Pointer<CHistories>,
              ffi.Pointer<CDocuments>,
              ffi.Pointer<CError>)>>('xaynai_rerank');
  late final _xaynai_rerank = _xaynai_rerankPtr.asFunction<
      ffi.Pointer<CRerankingOutcomes> Function(
          ffi.Pointer<CXaynAi>,
          int,
          ffi.Pointer<CHistories>,
          ffi.Pointer<CDocuments>,
          ffi.Pointer<CError>)>();

  /// Serializes the database of the reranker.
  ///
  /// # Errors
  /// Returns a null pointer if:
  /// - The xaynai is null.
  /// - The serialization fails.
  /// - An unexpected panic happened.
  ///
  /// # Safety
  /// The behavior is undefined if:
  /// - A non-null xaynai doesn't point to memory allocated by [`xaynai_new()`].
  /// - A non-null error doesn't point to an aligned, contiguous area of memory with a [`CError`].
  ffi.Pointer<CBytes> xaynai_serialize(
    ffi.Pointer<CXaynAi> xaynai,
    ffi.Pointer<CError> error,
  ) {
    return _xaynai_serialize(
      xaynai,
      error,
    );
  }

  late final _xaynai_serializePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<CBytes> Function(
              ffi.Pointer<CXaynAi>, ffi.Pointer<CError>)>>('xaynai_serialize');
  late final _xaynai_serialize = _xaynai_serializePtr.asFunction<
      ffi.Pointer<CBytes> Function(
          ffi.Pointer<CXaynAi>, ffi.Pointer<CError>)>();

  /// Retrieves faults which might occur during reranking.
  ///
  /// Faults can range from warnings to errors which are handled in some default way internally.
  ///
  /// # Errors
  /// Returns a null pointer if:
  /// - The `xaynai` is null.
  /// - An unexpected panic happened.
  ///
  /// # Safety
  /// The behavior is undefined if:
  /// - A non-null `xaynai` doesn't point to memory allocated by [`xaynai_new()`].
  /// - A non-null `error` doesn't point to an aligned, contiguous area of memory with a [`CError`].
  ffi.Pointer<CFaults> xaynai_faults(
    ffi.Pointer<CXaynAi> xaynai,
    ffi.Pointer<CError> error,
  ) {
    return _xaynai_faults(
      xaynai,
      error,
    );
  }

  late final _xaynai_faultsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<CFaults> Function(
              ffi.Pointer<CXaynAi>, ffi.Pointer<CError>)>>('xaynai_faults');
  late final _xaynai_faults = _xaynai_faultsPtr.asFunction<
      ffi.Pointer<CFaults> Function(
          ffi.Pointer<CXaynAi>, ffi.Pointer<CError>)>();

  /// Retrieves the analytics which were collected in the penultimate reranking.
  ///
  /// # Errors
  /// Returns a null pointer if:
  /// - The `xaynai` is null.
  /// - An unexpected panic happened.
  ///
  /// # Safety
  /// The behavior is undefined if:
  /// - A non-null `xaynai` doesn't point to memory allocated by [`xaynai_new()`].
  /// - A non-null `error` doesn't point to an aligned, contiguous area of memory with a [`CError`].
  ffi.Pointer<CAnalytics> xaynai_analytics(
    ffi.Pointer<CXaynAi> xaynai,
    ffi.Pointer<CError> error,
  ) {
    return _xaynai_analytics(
      xaynai,
      error,
    );
  }

  late final _xaynai_analyticsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<CAnalytics> Function(
              ffi.Pointer<CXaynAi>, ffi.Pointer<CError>)>>('xaynai_analytics');
  late final _xaynai_analytics = _xaynai_analyticsPtr.asFunction<
      ffi.Pointer<CAnalytics> Function(
          ffi.Pointer<CXaynAi>, ffi.Pointer<CError>)>();

  /// Serializes the synchronizable data of the reranker.
  ///
  /// # Errors
  /// Returns a null pointer if:
  /// - The xaynai is null.
  /// - The serialization fails.
  /// - An unexpected panic happened.
  ///
  /// # Safety
  /// The behavior is undefined if:
  /// - A non-null xaynai doesn't point to memory allocated by [`xaynai_new()`].
  /// - A non-null error doesn't point to an aligned, contiguous area of memory with a [`CError`].
  ffi.Pointer<CBytes> xaynai_syncdata_bytes(
    ffi.Pointer<CXaynAi> xaynai,
    ffi.Pointer<CError> error,
  ) {
    return _xaynai_syncdata_bytes(
      xaynai,
      error,
    );
  }

  late final _xaynai_syncdata_bytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<CBytes> Function(ffi.Pointer<CXaynAi>,
              ffi.Pointer<CError>)>>('xaynai_syncdata_bytes');
  late final _xaynai_syncdata_bytes = _xaynai_syncdata_bytesPtr.asFunction<
      ffi.Pointer<CBytes> Function(
          ffi.Pointer<CXaynAi>, ffi.Pointer<CError>)>();

  /// Synchronizes the internal data of the reranker with another.
  ///
  /// # Errors
  /// - The `xaynai` is null.
  /// - The serialized data `bytes` is null or invalid.
  /// - The synchronization failed.
  /// - An unexpected panic happened.
  ///
  /// In case of a [`CCode::Panic`] the Xayn AI must not be accessed anymore and should be dropped via
  /// [`xaynai_drop()`]. The last known valid state can be restored by the caller via [`xaynai_new()`]
  /// with a previously serialized reranker database obtained from [`xaynai_serialize()`].
  ///
  /// # Safety
  /// The behavior is undefined if:
  /// - A non-null `xaynai` doesn't point to memory allocated by [`xaynai_new()`].
  /// - The safety constraints of [`CBoxedSlice`] are violated.
  /// - A non-null `error` doesn't point to an aligned, contiguous area of memory with a [`CError`].
  ///
  /// [`CBoxedSlice`]: crate::utils::CBoxedSlice
  void xaynai_synchronize(
    ffi.Pointer<CXaynAi> xaynai,
    ffi.Pointer<CBytes> bytes,
    ffi.Pointer<CError> error,
  ) {
    return _xaynai_synchronize(
      xaynai,
      bytes,
      error,
    );
  }

  late final _xaynai_synchronizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<CXaynAi>, ffi.Pointer<CBytes>,
              ffi.Pointer<CError>)>>('xaynai_synchronize');
  late final _xaynai_synchronize = _xaynai_synchronizePtr.asFunction<
      void Function(
          ffi.Pointer<CXaynAi>, ffi.Pointer<CBytes>, ffi.Pointer<CError>)>();

  /// Frees the memory of the Xayn AI.
  ///
  /// # Safety
  /// The behavior is undefined if:
  /// - A non-null `xaynai` doesn't point to memory allocated by [`xaynai_new()`].
  /// - A non-null `xaynai` is freed more than once.
  /// - A non-null `xaynai` is accessed after being freed.
  void xaynai_drop(
    ffi.Pointer<CXaynAi> _xaynai,
  ) {
    return _xaynai_drop(
      _xaynai,
    );
  }

  late final _xaynai_dropPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<CXaynAi>)>>(
          'xaynai_drop');
  late final _xaynai_drop =
      _xaynai_dropPtr.asFunction<void Function(ffi.Pointer<CXaynAi>)>();

  /// Frees the memory of the analytics.
  ///
  /// # Safety
  /// The behavior is undefined if:
  /// - A non-null `analytics` doesn't point to memory allocated by [`xaynai_analytics()`].
  /// - A non-null `analytics` is freed more than once.
  /// - A non-null `analytics` is accessed after being freed.
  ///
  /// [`xaynai_analytics()`]: crate::reranker::ai::xaynai_analytics
  void analytics_drop(
    ffi.Pointer<CAnalytics> _analytics,
  ) {
    return _analytics_drop(
      _analytics,
    );
  }

  late final _analytics_dropPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<CAnalytics>)>>(
          'analytics_drop');
  late final _analytics_drop =
      _analytics_dropPtr.asFunction<void Function(ffi.Pointer<CAnalytics>)>();

  /// Creates a zeroized, owned bytes buffer.
  ///
  /// # Errors
  /// Returns a null pointer if:
  /// - An unexpected panic happened.
  ///
  /// # Safety
  /// The behavior is undefined if:
  /// - A `len` is too large to address the memory of a non-null [`u8`] array.
  /// - A non-null `error` doesn't point to an aligned, contiguous area of memory with a [`CError`].
  ffi.Pointer<CBytes> bytes_new(
    int len,
    ffi.Pointer<CError> error,
  ) {
    return _bytes_new(
      len,
      error,
    );
  }

  late final _bytes_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<CBytes> Function(
              ffi.Uint64, ffi.Pointer<CError>)>>('bytes_new');
  late final _bytes_new = _bytes_newPtr
      .asFunction<ffi.Pointer<CBytes> Function(int, ffi.Pointer<CError>)>();

  /// Frees the memory of the bytes buffer.
  ///
  /// # Safety
  /// The behavior is undefined if:
  /// - A non-null `bytes` buffer doesn't point to memory allocated by [`bytes_new()`] or
  /// [`xaynai_serialize()`].
  /// - A non-null `bytes` buffer is freed more than once.
  /// - A non-null `bytes` buffer is accessed after being freed.
  ///
  /// [`xaynai_serialize()`]: crate::reranker::ai::xaynai_serialize
  void bytes_drop(
    ffi.Pointer<CBytes> _bytes,
  ) {
    return _bytes_drop(
      _bytes,
    );
  }

  late final _bytes_dropPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<CBytes>)>>(
          'bytes_drop');
  late final _bytes_drop =
      _bytes_dropPtr.asFunction<void Function(ffi.Pointer<CBytes>)>();

  /// Frees the memory of the error message.
  ///
  /// This *does not* free the error memory itself, which is allocated somewhere else. But this *does*
  /// free the message field memory of the error. Not freeing the error message on consecutive errors
  /// (ie. where the error code is not success) will potentially leak the error message memory of the
  /// overwritten error.
  ///
  /// # Safety
  /// The behavior is undefined if:
  /// - A non-null `error` doesn't point to an aligned, contiguous area of memory with a [`CError`].
  /// - A non-null error `message` doesn't point to memory allocated by [`xaynai_new()`],
  /// [`xaynai_rerank()`], [`xaynai_serialize()`], [`xaynai_faults()`], [`xaynai_analytics()`] or
  /// [`bytes_new()`].
  /// - A non-null error `message` is freed more than once.
  /// - A non-null error `message` is accessed after being freed.
  ///
  /// [`xaynai_new()`]: crate::reranker::ai::xaynai_new
  /// [`xaynai_rerank()`]: crate::reranker::ai::xaynai_rerank
  /// [`xaynai_serialize()`]: crate::reranker::ai::xaynai_serialize
  /// [`xaynai_faults()`]: crate::reranker::ai::xaynai_faults
  /// [`xaynai_analytics()`]: crate::reranker::ai::xaynai_analytics
  /// [`bytes_new()`]: crate::reranker::bytes::bytes_new
  void error_message_drop(
    ffi.Pointer<CError> error,
  ) {
    return _error_message_drop(
      error,
    );
  }

  late final _error_message_dropPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<CError>)>>(
          'error_message_drop');
  late final _error_message_drop =
      _error_message_dropPtr.asFunction<void Function(ffi.Pointer<CError>)>();

  /// Frees the memory of the faults.
  ///
  /// # Safety
  /// The behavior is undefined if:
  /// - A non-null `faults` doesn't point to memory allocated by [`xaynai_faults()`].
  /// - A non-null `faults` is freed more than once.
  /// - A non-null `faults` is accessed after being freed.
  ///
  /// [`xaynai_faults()`]: crate::reranker::ai::xaynai_faults
  void faults_drop(
    ffi.Pointer<CFaults> _faults,
  ) {
    return _faults_drop(
      _faults,
    );
  }

  late final _faults_dropPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<CFaults>)>>(
          'faults_drop');
  late final _faults_drop =
      _faults_dropPtr.asFunction<void Function(ffi.Pointer<CFaults>)>();
}

class CXaynAi extends ffi.Opaque {}

/// A boxed slice with a C-compatible ABI.
///
/// # C Layout
/// ```
/// struct CBoxedSlice<T> {
/// data: *mut T,
/// len: u64,
/// }
/// ```
///
/// # Safety
/// If the boxed slice is only used within safe Rust or only immutably accessed outside of safe
/// Rust, everything is sound and effectively behaves like a `Box<[T]>`.
///
/// However, if it is mutably accessed outside of safe Rust, then it is undefined behavior if:
/// - A non-null `data` pointer doesn't point to an aligned, contiguous area of memory with exactly
/// `len` many `T`s.
/// - A null or dangling `data` pointer doesn't have `len` zero.
/// - A `len` is too large to address a corresponding `[T]`.
///
/// Also, it's undefined behavior to transfer ownership of a boxed slice to Rust which wasn't
/// allocated in Rust before.
///
/// A partial soundness check can be done via `is_sound()`, but this is of course only feasible to a
/// certain extend, ultimatly the caller is responsible to guarantee soundness when transferring
/// this over the FFI boundary.
class CBoxedSlice_u16 extends ffi.Struct {
  external ffi.Pointer<ffi.Uint16> data;

  @ffi.Uint64()
  external int len;
}

/// A boxed slice with a C-compatible ABI.
///
/// # C Layout
/// ```
/// struct CBoxedSlice<T> {
/// data: *mut T,
/// len: u64,
/// }
/// ```
///
/// # Safety
/// If the boxed slice is only used within safe Rust or only immutably accessed outside of safe
/// Rust, everything is sound and effectively behaves like a `Box<[T]>`.
///
/// However, if it is mutably accessed outside of safe Rust, then it is undefined behavior if:
/// - A non-null `data` pointer doesn't point to an aligned, contiguous area of memory with exactly
/// `len` many `T`s.
/// - A null or dangling `data` pointer doesn't have `len` zero.
/// - A `len` is too large to address a corresponding `[T]`.
///
/// Also, it's undefined behavior to transfer ownership of a boxed slice to Rust which wasn't
/// allocated in Rust before.
///
/// A partial soundness check can be done via `is_sound()`, but this is of course only feasible to a
/// certain extend, ultimatly the caller is responsible to guarantee soundness when transferring
/// this over the FFI boundary.
class CBoxedSlice_f32 extends ffi.Struct {
  external ffi.Pointer<ffi.Float> data;

  @ffi.Uint64()
  external int len;
}

/// C-FFI accessible version of [`RerankingOutcomes`].
///
/// [`RerankingOutcomes`]: xayn_ai::RerankingOutcomes
class CRerankingOutcomes extends ffi.Struct {
  /// The final ranking.
  ///
  /// See [`RerankingOutcomes.final_ranking`].
  ///
  /// Should only be empty if the input document list was empty.
  ///
  /// [`RerankingOutcomes.final_ranking`]: xayn_ai::RerankingOutcomes::final_ranking
  external CBoxedSlice_u16 final_ranking;

  /// See [`RerankingOutcomes.qambert_similarities`].
  ///
  /// If it was `None` the `CBoxedSlice` instance will have a
  /// null-pointer and a length of 0.
  ///
  /// If it was `Some` but still empty it will have a dangling
  /// pointer and a length of 0.
  ///
  /// [`RerankingOutcomes.qambert_similarities`]: xayn_ai::RerankingOutcomes::qambert_similarities
  external CBoxedSlice_f32 qambert_similarities;

  /// See [`RerankingOutcomes.context_scores`].
  ///
  /// If it was `None` the `CBoxedSlice` instance will have a
  /// null-pointer and a length of 0.
  ///
  /// If it was `Some` but still empty it will have a dangling
  /// pointer and a length of 0.
  ///
  /// [`RerankingOutcomes.context_scores`]: xayn_ai::RerankingOutcomes::context_scores
  external CBoxedSlice_f32 context_scores;
}

/// A boxed slice with a C-compatible ABI.
///
/// # C Layout
/// ```
/// struct CBoxedSlice<T> {
/// data: *mut T,
/// len: u64,
/// }
/// ```
///
/// # Safety
/// If the boxed slice is only used within safe Rust or only immutably accessed outside of safe
/// Rust, everything is sound and effectively behaves like a `Box<[T]>`.
///
/// However, if it is mutably accessed outside of safe Rust, then it is undefined behavior if:
/// - A non-null `data` pointer doesn't point to an aligned, contiguous area of memory with exactly
/// `len` many `T`s.
/// - A null or dangling `data` pointer doesn't have `len` zero.
/// - A `len` is too large to address a corresponding `[T]`.
///
/// Also, it's undefined behavior to transfer ownership of a boxed slice to Rust which wasn't
/// allocated in Rust before.
///
/// A partial soundness check can be done via `is_sound()`, but this is of course only feasible to a
/// certain extend, ultimatly the caller is responsible to guarantee soundness when transferring
/// this over the FFI boundary.
class CBoxedSlice_u8 extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> data;

  @ffi.Uint64()
  external int len;
}

/// The raw Xayn AI error information.
class CError extends ffi.Struct {
  /// The error code.
  @CCode()
  external int code;

  /// The raw pointer to the error message.
  external ffi.Pointer<CBytes> message;
}

typedef CCode = ffi.Int8;

/// A raw slice of bytes.
typedef CBytes = CBoxedSlice_u8;

/// A raw document history.
class CHistory extends ffi.Struct {
  /// The raw pointer to the document id.
  external ffi.Pointer<ffi.Uint8> id;

  /// The relevance level of the document.
  @Relevance()
  external int relevance;

  /// The user feedback level of the document.
  @UserFeedback()
  external int user_feedback;

  /// The raw pointer to the session id of the document.
  external ffi.Pointer<ffi.Uint8> session;

  /// The query count within the session.
  @ffi.Uint32()
  external int query_count;

  /// The raw pointer to the query id of the document.
  external ffi.Pointer<ffi.Uint8> query_id;

  /// The raw pointer to the query words.
  external ffi.Pointer<ffi.Uint8> query_words;

  /// The day of the week the query was performed.
  @DayOfWeek()
  external int day;

  /// The raw pointer to the url of the document.
  external ffi.Pointer<ffi.Uint8> url;

  /// The raw pointer to the domain of the document.
  external ffi.Pointer<ffi.Uint8> domain;

  /// The rank of the document.
  @ffi.Uint32()
  external int rank;

  /// The user interaction for the document.
  @UserAction()
  external int user_action;
}

typedef Relevance = ffi.Uint8;
typedef UserFeedback = ffi.Uint8;
typedef DayOfWeek = ffi.Uint8;
typedef UserAction = ffi.Uint8;

/// A raw slice of document histories.
class CHistories extends ffi.Struct {
  /// The raw pointer to the document histories.
  external ffi.Pointer<CHistory> data;

  /// The number of document histories.
  @ffi.Uint32()
  external int len;
}

/// A raw document.
class CDocument extends ffi.Struct {
  /// The raw pointer to the document id.
  external ffi.Pointer<ffi.Uint8> id;

  /// The raw pointer to the document title.
  external ffi.Pointer<ffi.Uint8> title;

  /// The raw pointer to the document snippet.
  external ffi.Pointer<ffi.Uint8> snippet;

  /// The rank of the document.
  @ffi.Uint32()
  external int rank;

  /// The raw pointer to the document session id.
  external ffi.Pointer<ffi.Uint8> session;

  /// Query count within session
  @ffi.Uint32()
  external int query_count;

  /// The raw pointer to the document query id.
  external ffi.Pointer<ffi.Uint8> query_id;

  /// The raw pointer to the document query words.
  external ffi.Pointer<ffi.Uint8> query_words;

  /// The raw pointer to the document URL.
  external ffi.Pointer<ffi.Uint8> url;

  /// The raw pointer to the document domain.
  external ffi.Pointer<ffi.Uint8> domain;
}

/// A raw slice of documents.
class CDocuments extends ffi.Struct {
  /// The raw pointer to the documents.
  external ffi.Pointer<CDocument> data;

  /// The number of documents.
  @ffi.Uint32()
  external int len;
}

/// A boxed slice with a C-compatible ABI.
///
/// # C Layout
/// ```
/// struct CBoxedSlice<T> {
/// data: *mut T,
/// len: u64,
/// }
/// ```
///
/// # Safety
/// If the boxed slice is only used within safe Rust or only immutably accessed outside of safe
/// Rust, everything is sound and effectively behaves like a `Box<[T]>`.
///
/// However, if it is mutably accessed outside of safe Rust, then it is undefined behavior if:
/// - A non-null `data` pointer doesn't point to an aligned, contiguous area of memory with exactly
/// `len` many `T`s.
/// - A null or dangling `data` pointer doesn't have `len` zero.
/// - A `len` is too large to address a corresponding `[T]`.
///
/// Also, it's undefined behavior to transfer ownership of a boxed slice to Rust which wasn't
/// allocated in Rust before.
///
/// A partial soundness check can be done via `is_sound()`, but this is of course only feasible to a
/// certain extend, ultimatly the caller is responsible to guarantee soundness when transferring
/// this over the FFI boundary.
class CBoxedSlice_CError extends ffi.Struct {
  external ffi.Pointer<CError> data;

  @ffi.Uint64()
  external int len;
}

/// The raw analytics of the reranker.
class CAnalytics extends ffi.Struct {
  /// The nDCG@k score between the LTR ranking and the relevance based ranking.
  @ffi.Float()
  external double ndcg_ltr;

  /// The nDCG@k score between the Context ranking and the relevance based ranking.
  @ffi.Float()
  external double ndcg_context;

  /// The nDCG@k score between the initial ranking and the relevance based ranking.
  @ffi.Float()
  external double ndcg_initial_ranking;

  /// The nDCG@k score between the final ranking and the relevance based ranking.
  @ffi.Float()
  external double ndcg_final_ranking;
}

typedef RerankMode = ffi.Uint8;

/// A raw slice of faults.
typedef CFaults = CBoxedSlice_CError;
